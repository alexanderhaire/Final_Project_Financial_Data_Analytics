import alpaca_trade_api as tradeapi
import pandas as pd
import numpy as np
import yfinance as yf
import time
from xgboost import XGBClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import TimeSeriesSplit, GridSearchCV
import warnings

# Alpaca API credentials
API_KEY = 'PK753KPEQ2WUPJWJRSGD'
API_SECRET = '7vVGcSCohZT9ljTks7Jh1zny5mVeMjRrD7duLirU'
BASE_URL = 'https://paper-api.alpaca.markets'

# Suppress warnings
warnings.filterwarnings("ignore", category=UserWarning)

# Initialize the Alpaca API
api = tradeapi.REST(API_KEY, API_SECRET, BASE_URL, api_version='v2')

# Function to get historical data from Yahoo Finance and preprocess
def get_historical_data(ticker, start_date="2010-01-01", end_date="2024-01-01"):
    data = yf.download(ticker, start=start_date, end=end_date)
    data['50_MA'] = data['Close'].rolling(window=50).mean()
    data['200_MA'] = data['Close'].rolling(window=200).mean()
    delta = data['Close'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    data['RSI'] = 100 - (100 / (1 + rs))
    data.dropna(inplace=True)
    return data

# Function to train the model using XGBoost with walk-forward validation across multiple tickers
def train_model(tickers):
    combined_data = []
    for ticker in tickers:
        data = get_historical_data(ticker)
        data['Ticker'] = ticker  # Add a column for the ticker
        combined_data.append(data)

    all_data = pd.concat(combined_data)
    all_data['Lag_1'] = all_data['Close'].shift(1)
    all_data['Lag_2'] = all_data['Close'].shift(2)
    all_data['Target'] = np.where(all_data['Close'].shift(-1) > all_data['Close'], 1, 0)
    all_data.dropna(inplace=True)

    features = ['Lag_1', 'Lag_2', '50_MA', '200_MA', 'RSI', 'Close']
    X = all_data[features]
    y = all_data['Target']

    # Standardize features
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    # Time series split for walk-forward validation
    tscv = TimeSeriesSplit(n_splits=5)

    # XGBoost model
    xgb_model = XGBClassifier(eval_metric='logloss', use_label_encoder=False)

    # Grid search parameters
    param_grid = {
        'n_estimators': [50, 100],
        'learning_rate': [0.01, 0.1],
        'max_depth': [3, 5]
    }

    grid_search = GridSearchCV(xgb_model, param_grid, cv=tscv, n_jobs=-1)
    grid_search.fit(X_scaled, y)

    print(f"Best parameters: {grid_search.best_params_}")
    print(f"Best score: {grid_search.best_score_}")

    best_model = grid_search.best_estimator_
    return best_model, scaler

# Function to get the latest data from Alpaca and preprocess it
def get_latest_data(ticker, timeframe='1Min'):
    try:
        clock = api.get_clock()
        if not clock.is_open:
            print("Market is currently closed.")
            return pd.DataFrame()

        bars = api.get_bars(ticker, timeframe=timeframe, limit=200).df
        if bars.empty:
            print("No data returned from Alpaca.")
            return pd.DataFrame()

        df = pd.DataFrame(bars.reset_index())
        df.rename(columns={'close': 'Close', 'high': 'High', 'low': 'Low', 'open': 'Open', 'volume': 'Volume'}, inplace=True)
        
        if 'Close' in df:
            df['50_MA'] = df['Close'].rolling(window=50).mean()
            df['200_MA'] = df['Close'].rolling(window=200).mean()
            delta = df['Close'].diff(1)
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['RSI'] = 100 - (100 / (1 + rs))
        
        df.dropna(inplace=True)
        return df
    
    except Exception as e:
        print(f"Error retrieving data: {e}")
        return pd.DataFrame()

# Function to place an order
def place_order(symbol, qty, side, order_type='market'):
    try:
        api.submit_order(
            symbol=symbol,
            qty=qty,
            side=side,
            type=order_type,
            time_in_force='gtc'
        )
        print(f"Order placed: {side} {qty} shares of {symbol}")
    except Exception as e:
        print(f"Error placing order: {e}")

# Function to retrain the model periodically
def retrain_model(ticker, scaler):
    print(f"Retraining model for {ticker}...")
    historical_data = get_historical_data(ticker)
    model, new_scaler = train_model([ticker])
    return model, new_scaler

# Function to run the HFT strategy with periodic retraining
def run_hft_strategy(tickers, quantity, model_dict, scaler_dict, retrain_interval=3600):
    iteration_count = 0

    while True:
        for ticker in tickers:
            print(f"Running HFT strategy for {ticker}...")
            df = get_latest_data(ticker)
            if df.empty:
                print(f"No data available for {ticker}.")
                continue
            
            lag_1 = df['Close'].shift(1).iloc[-1]
            lag_2 = df['Close'].shift(2).iloc[-1]
            ma_50 = df['50_MA'].iloc[-1]
            ma_200 = df['200_MA'].iloc[-1]
            rsi = df['RSI'].iloc[-1]
            current_price = df['Close'].iloc[-1]

            # Prepare the input for the model
            X_new = np.array([[lag_1, lag_2, ma_50, ma_200, rsi, current_price]])
            X_new_scaled = scaler_dict[ticker].transform(X_new)

            prediction = model_dict[ticker].predict(X_new_scaled)

            try:
                position = api.get_position(ticker)
                current_qty = int(position.qty)
            except Exception:
                current_qty = 0

            # Make a trade based on the prediction
            if prediction == 1:
                place_order(ticker, quantity, 'buy')
                time.sleep(0.5)  # Short delay before placing the next order
                place_order(ticker, quantity, 'sell')
            elif prediction == 0:
                if current_qty > 0:
                    place_order(ticker, current_qty, 'sell')
                time.sleep(0.5)
                place_order(ticker, quantity, 'buy')

        # Periodic retraining every `retrain_interval` seconds
        iteration_count += 1
        if iteration_count % (retrain_interval // 60) == 0:
            print("Retraining models...")
            for ticker in tickers:
                model_dict[ticker], scaler_dict[ticker] = retrain_model(ticker, scaler_dict[ticker])

        account = api.get_account()
        print(f"Portfolio Value: {account.portfolio_value}")
        time.sleep(60)  # Adjust the sleep time as needed

# Main execution
tickers = ["AAPL", "GOOGL", "MSFT"]
model_dict = {}
scaler_dict = {}

# Train models for each ticker
for ticker in tickers:
    print(f"Training model for {ticker}...")
    historical_data = get_historical_data(ticker)
    model, scaler = train_model([ticker])
    model_dict[ticker] = model
    scaler_dict[ticker] = scaler

# Run the HFT strategy with periodic retraining
run_hft_strategy(tickers, 10, model_dict, scaler_dict, retrain_interval=1800)  # Retrains every 30 minutes

